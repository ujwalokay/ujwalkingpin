/* src/lib/tauri-db.ts
   Consolidated Tauri local DB adapter for Airavoto Gaming POS.
   This file provides complete offline functionality using local SQLite database.
*/

type AnyObject = Record<string, any>;

let db: any = null;
let dbInitPromise: Promise<any> | null = null;
let dbInitialized = false;

/**
 * Robust Tauri v2 detection.
 * - Prefer internal bridge existence if available.
 * - Fall back to userAgent check for "tauri".
 */
export function isTauri(): boolean {
  try {
    if (typeof window === 'undefined') return false;
    if ('__TAURI_INTERNALS__' in (window as any)) return true;
    if ('__TAURI__' in (window as any)) return true;
    if (typeof navigator !== 'undefined' && navigator.userAgent) {
      return navigator.userAgent.toLowerCase().includes('tauri');
    }
    return false;
  } catch {
    return false;
  }
}

/**
 * Initialize the Tauri SQL database (singleton).
 */
export async function initDatabase() {
  if (!isTauri()) {
    console.warn('[DB] Not in Tauri environment, skipping database init');
    return null;
  }

  if (db && dbInitialized) return db;
  if (dbInitPromise) return dbInitPromise;

  dbInitPromise = (async () => {
    try {
      console.log('[DB] Initializing Tauri database...');
      
      // Dynamic import with timeout to prevent hanging
      const importWithTimeout = async () => {
        return new Promise<any>((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('Plugin import timeout after 5 seconds'));
          }, 5000);
          
          import('@tauri-apps/plugin-sql')
            .then((module) => {
              clearTimeout(timeout);
              resolve(module);
            })
            .catch((err) => {
              clearTimeout(timeout);
              reject(err);
            });
        });
      };
      
      const sqlModule = await importWithTimeout();
      console.log('[DB] SQL module loaded:', Object.keys(sqlModule));
      
      const Database = sqlModule.default || (sqlModule as any).Database || sqlModule;
      
      if (typeof Database.load !== 'function') {
        throw new Error('Database.load is not a function - invalid SQL module');
      }
      
      db = await Database.load('sqlite:airavoto_pos.db');
      dbInitialized = true;
      console.log('[DB] Tauri database initialized successfully');
      return db;
    } catch (error) {
      console.error('[DB] Failed to initialize Tauri database:', error);
      dbInitPromise = null;
      dbInitialized = false;
      throw error;
    }
  })();

  return dbInitPromise;
}

/**
 * Get the initialized database instance.
 */
export async function getDatabase() {
  if (!isTauri()) {
    throw new Error('Cannot get Tauri database in web mode');
  }
  if (!db || !dbInitialized) {
    return initDatabase();
  }
  return db;
}

export function isDatabaseReady(): boolean {
  return isTauri() && dbInitialized && db !== null;
}

/* Utility helpers */
function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

function generateCode(prefix: string): string {
  const timestamp = Date.now().toString(36).toUpperCase();
  const randomPart = Math.floor(Math.random() * 0xFFFFFF)
    .toString(16)
    .toUpperCase()
    .padStart(6, '0');
  return `${prefix}-${timestamp.slice(-5)}${randomPart.slice(0, 4)}`;
}

function snakeToCamel(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

function transformRow(row: AnyObject): AnyObject {
  const transformed: AnyObject = {};
  for (const [key, value] of Object.entries(row)) {
    const camelKey = snakeToCamel(key);
    transformed[camelKey] = value;
  }
  return transformed;
}

function safeJsonParse<T = any>(s: any, fallback: T): T {
  if (s === null || s === undefined) return fallback;
  try {
    return JSON.parse(s);
  } catch {
    return fallback;
  }
}

function parseDate(value: any): Date | null {
  if (!value) return null;
  if (value instanceof Date) return value;
  const parsed = new Date(value);
  return isNaN(parsed.getTime()) ? null : parsed;
}

function parseDateRequired(value: any): Date {
  if (!value) return new Date();
  if (value instanceof Date) return value;
  const parsed = new Date(value);
  return isNaN(parsed.getTime()) ? new Date() : parsed;
}

function transformBookingRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    bookingCode: row.booking_code,
    groupId: row.group_id,
    groupCode: row.group_code,
    category: row.category,
    seatNumber: row.seat_number,
    seatName: row.seat_name,
    customerName: row.customer_name,
    whatsappNumber: row.whatsapp_number,
    startTime: parseDateRequired(row.start_time),
    endTime: parseDateRequired(row.end_time),
    price: row.price,
    status: row.status,
    bookingType: safeJsonParse(row.booking_type, []),
    pausedRemainingTime: row.paused_remaining_time,
    personCount: row.person_count,
    paymentMethod: row.payment_method,
    cashAmount: row.cash_amount,
    upiAmount: row.upi_amount,
    paymentStatus: row.payment_status,
    lastPaymentAction: safeJsonParse(row.last_payment_action, null),
    foodOrders: safeJsonParse(row.food_orders, []),
    originalPrice: row.original_price,
    discountApplied: row.discount_applied,
    bonusHoursApplied: row.bonus_hours_applied,
    promotionDetails: safeJsonParse(row.promotion_details, null),
    isPromotionalDiscount: row.is_promotional_discount,
    isPromotionalBonus: row.is_promotional_bonus,
    manualDiscountPercentage: row.manual_discount_percentage,
    manualFreeHours: row.manual_free_hours,
    discount: row.discount,
    bonus: row.bonus,
    createdAt: parseDateRequired(row.created_at),
  };
}

function transformFoodItemRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    name: row.name,
    price: row.price,
    costPrice: row.cost_price,
    currentStock: row.current_stock,
    minStockLevel: row.min_stock_level,
    inInventory: row.in_inventory,
    category: row.category,
    supplier: row.supplier,
    expiryDate: parseDate(row.expiry_date),
  };
}

function transformExpenseRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    category: row.category,
    description: row.description,
    amount: row.amount,
    date: parseDateRequired(row.date),
    createdAt: parseDateRequired(row.created_at),
  };
}

function transformActivityLogRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    userId: row.user_id,
    username: row.username,
    userRole: row.user_role,
    action: row.action,
    entityType: row.entity_type,
    entityId: row.entity_id,
    details: row.details,
    createdAt: parseDateRequired(row.created_at),
  };
}

function transformNotificationRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    type: row.type,
    title: row.title,
    message: row.message,
    entityType: row.entity_type,
    entityId: row.entity_id,
    activityLogId: row.activity_log_id,
    isRead: row.is_read,
    createdAt: parseDateRequired(row.created_at),
  };
}

function transformUserRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    username: row.username,
    role: row.role,
    onboardingCompleted: row.onboarding_completed,
    profileImageUrl: row.profile_image_url,
    createdAt: parseDateRequired(row.created_at),
    updatedAt: parseDate(row.updated_at),
  };
}

function transformDeviceConfigRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    category: row.category,
    count: row.count,
    seats: safeJsonParse(row.seats, []),
  };
}

function transformPricingConfigRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    category: row.category,
    duration: row.duration,
    price: row.price,
    personCount: row.person_count,
  };
}

function transformBookingHistoryRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    bookingId: row.booking_id,
    bookingCode: row.booking_code,
    groupId: row.group_id,
    groupCode: row.group_code,
    category: row.category,
    seatNumber: row.seat_number,
    seatName: row.seat_name,
    customerName: row.customer_name,
    whatsappNumber: row.whatsapp_number,
    startTime: parseDateRequired(row.start_time),
    endTime: parseDateRequired(row.end_time),
    price: row.price,
    status: row.status,
    bookingType: safeJsonParse(row.booking_type, []),
    pausedRemainingTime: row.paused_remaining_time,
    personCount: row.person_count,
    paymentMethod: row.payment_method,
    cashAmount: row.cash_amount,
    upiAmount: row.upi_amount,
    paymentStatus: row.payment_status,
    lastPaymentAction: safeJsonParse(row.last_payment_action, null),
    foodOrders: safeJsonParse(row.food_orders, []),
    originalPrice: row.original_price,
    discountApplied: row.discount_applied,
    bonusHoursApplied: row.bonus_hours_applied,
    promotionDetails: safeJsonParse(row.promotion_details, null),
    isPromotionalDiscount: row.is_promotional_discount,
    isPromotionalBonus: row.is_promotional_bonus,
    manualDiscountPercentage: row.manual_discount_percentage,
    manualFreeHours: row.manual_free_hours,
    discount: row.discount,
    bonus: row.bonus,
    createdAt: parseDateRequired(row.created_at),
    archivedAt: parseDate(row.archived_at),
  };
}

function transformGamingCenterInfoRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    name: row.name,
    description: row.description,
    address: row.address,
    phone: row.phone,
    email: row.email,
    hours: row.hours,
    timezone: row.timezone,
    updatedAt: parseDate(row.updated_at),
  };
}

function transformSessionGroupRow(row: any): any {
  if (!row) return null;
  return {
    id: row.id,
    groupCode: row.group_code,
    groupName: row.group_name,
    category: row.category,
    bookingType: safeJsonParse(row.booking_type, []),
    createdAt: parseDateRequired(row.created_at),
  };
}

// Parse time string (supports both "11:00 AM" and "11:00" formats) to minutes since midnight
function parseTimeToMinutes(timeStr: string): number {
  if (!timeStr) return 0;
  
  // Check for AM/PM format
  const isPM = timeStr.toUpperCase().includes('PM');
  const isAM = timeStr.toUpperCase().includes('AM');
  
  // Remove AM/PM and trim
  const cleanTime = timeStr.replace(/\s*(AM|PM)\s*/gi, '').trim();
  const [hoursStr, minutesStr] = cleanTime.split(':');
  let hours = parseInt(hoursStr) || 0;
  const minutes = parseInt(minutesStr) || 0;
  
  // Convert to 24-hour format if AM/PM present
  if (isPM && hours !== 12) {
    hours += 12;
  } else if (isAM && hours === 12) {
    hours = 0;
  }
  
  return hours * 60 + minutes;
}

/* -------------------------
   localDb API (all functions)
   ------------------------- */
export const localDb = {
  /* BOOKINGS */
  async getAllBookings() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM bookings ORDER BY created_at DESC');
    return (result || []).map(transformBookingRow);
  },

  async getActiveBookings() {
    const database = await getDatabase();
    const result = await database.select(
      "SELECT * FROM bookings WHERE status IN ('running', 'paused', 'upcoming') ORDER BY start_time"
    );
    return (result || []).map(transformBookingRow);
  },

  async getBookingById(id: string) {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM bookings WHERE id = $1', [id]);
    return result[0] ? transformBookingRow(result[0]) : null;
  },

  async createBooking(booking: any) {
    const database = await getDatabase();
    const id = generateUUID();
    const bookingCode = generateCode('BK');
    const now = new Date().toISOString();

    // Apply manual free hours if set (extend endTime like server does)
    let finalEndTime = booking.endTime;
    let bonusHoursApplied = booking.bonusHoursApplied || null;
    let originalPrice = booking.originalPrice || null;
    let isPromotionalBonus = booking.isPromotionalBonus ? 1 : 0;
    
    if (booking.manualFreeHours) {
      const freeHoursStr = String(booking.manualFreeHours);
      if (freeHoursStr.includes(':')) {
        const [hours, minutes] = freeHoursStr.split(':').map((v: string) => parseInt(v) || 0);
        const freeHoursValue = hours + (minutes / 60);
        if (freeHoursValue > 0) {
          const originalEndTime = new Date(booking.endTime);
          finalEndTime = new Date(originalEndTime.getTime() + (freeHoursValue * 60 * 60 * 1000)).toISOString();
          originalPrice = booking.price;
          const displayFormat = minutes > 0 ? `${hours}h ${minutes}min` : `${hours}h`;
          bonusHoursApplied = `+${displayFormat} (manual)`;
          isPromotionalBonus = 0;
        }
      }
    }

    await database.execute(
      `INSERT INTO bookings (
        id, booking_code, group_id, group_code, category, seat_number, seat_name,
        customer_name, whatsapp_number, start_time, end_time, price, status,
        booking_type, paused_remaining_time, person_count, payment_method,
        cash_amount, upi_amount, payment_status, last_payment_action, food_orders,
        original_price, discount_applied, bonus_hours_applied, promotion_details,
        is_promotional_discount, is_promotional_bonus, manual_discount_percentage,
        manual_free_hours, discount, bonus, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)`,
      [
        id, bookingCode, booking.groupId || null, booking.groupCode || null,
        booking.category, booking.seatNumber, booking.seatName,
        booking.customerName, booking.whatsappNumber || null,
        booking.startTime, finalEndTime, booking.price, booking.status,
        JSON.stringify(booking.bookingType || []), booking.pausedRemainingTime || null,
        booking.personCount || 1, booking.paymentMethod || null,
        booking.cashAmount || null, booking.upiAmount || null,
        booking.paymentStatus || 'unpaid', JSON.stringify(booking.lastPaymentAction || null),
        JSON.stringify(booking.foodOrders || []), originalPrice,
        booking.discountApplied || null, bonusHoursApplied,
        JSON.stringify(booking.promotionDetails || null), booking.isPromotionalDiscount ? 1 : 0,
        isPromotionalBonus, booking.manualDiscountPercentage || null,
        booking.manualFreeHours || null, booking.discount || null, booking.bonus || null, now
      ]
    );

    return {
      id,
      bookingCode,
      groupId: booking.groupId || null,
      groupCode: booking.groupCode || null,
      category: booking.category,
      seatNumber: booking.seatNumber,
      seatName: booking.seatName,
      customerName: booking.customerName,
      whatsappNumber: booking.whatsappNumber || null,
      startTime: booking.startTime,
      endTime: finalEndTime,
      price: booking.price,
      status: booking.status,
      bookingType: booking.bookingType || [],
      pausedRemainingTime: booking.pausedRemainingTime || null,
      personCount: booking.personCount || 1,
      paymentMethod: booking.paymentMethod || null,
      cashAmount: booking.cashAmount || null,
      upiAmount: booking.upiAmount || null,
      paymentStatus: booking.paymentStatus || 'unpaid',
      lastPaymentAction: booking.lastPaymentAction || null,
      foodOrders: booking.foodOrders || [],
      originalPrice: originalPrice,
      discountApplied: booking.discountApplied || null,
      bonusHoursApplied: bonusHoursApplied,
      promotionDetails: booking.promotionDetails || null,
      isPromotionalDiscount: booking.isPromotionalDiscount ? 1 : 0,
      isPromotionalBonus: isPromotionalBonus,
      manualDiscountPercentage: booking.manualDiscountPercentage || null,
      manualFreeHours: booking.manualFreeHours || null,
      discount: booking.discount || null,
      bonus: booking.bonus || null,
      createdAt: now,
    };
  },

  async updateBooking(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      return await this.getBookingById(id);
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const fieldMappings: Record<string, string> = {
      groupId: 'group_id', groupCode: 'group_code', seatNumber: 'seat_number',
      seatName: 'seat_name', customerName: 'customer_name', whatsappNumber: 'whatsapp_number',
      startTime: 'start_time', endTime: 'end_time', bookingType: 'booking_type',
      pausedRemainingTime: 'paused_remaining_time', personCount: 'person_count',
      paymentMethod: 'payment_method', cashAmount: 'cash_amount', upiAmount: 'upi_amount',
      paymentStatus: 'payment_status', lastPaymentAction: 'last_payment_action',
      foodOrders: 'food_orders', originalPrice: 'original_price', discountApplied: 'discount_applied',
      bonusHoursApplied: 'bonus_hours_applied', promotionDetails: 'promotion_details',
      isPromotionalDiscount: 'is_promotional_discount', isPromotionalBonus: 'is_promotional_bonus',
      manualDiscountPercentage: 'manual_discount_percentage', manualFreeHours: 'manual_free_hours',
    };

    for (const [key, value] of Object.entries(updates)) {
      const dbField = fieldMappings[key] || key;
      setClauses.push(`${dbField} = $${paramIndex}`);
      if (['bookingType', 'foodOrders', 'lastPaymentAction', 'promotionDetails'].includes(key)) {
        values.push(JSON.stringify(value));
      } else {
        values.push(value);
      }
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE bookings SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    
    const updated = await this.getBookingById(id);
    return updated;
  },

  async deleteBooking(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM bookings WHERE id = $1', [id]);
  },

  /* FOOD ITEMS */
  async getAllFoodItems() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM food_items ORDER BY name');
    return (result || []).map(transformFoodItemRow);
  },

  async getFoodItemById(id: string) {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM food_items WHERE id = $1', [id]);
    return result[0] ? transformFoodItemRow(result[0]) : null;
  },

  async createFoodItem(item: any) {
    const database = await getDatabase();
    const id = generateUUID();
    await database.execute(
      `INSERT INTO food_items (id, name, price, cost_price, current_stock, min_stock_level, in_inventory, category, supplier, expiry_date)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
      [id, item.name, item.price, item.costPrice || null, item.currentStock || 0,
       item.minStockLevel || 10, item.inInventory || 0, item.category || 'trackable',
       item.supplier || null, item.expiryDate || null]
    );
    return {
      id,
      name: item.name,
      price: item.price,
      costPrice: item.costPrice || null,
      currentStock: item.currentStock || 0,
      minStockLevel: item.minStockLevel || 10,
      inInventory: item.inInventory || 0,
      category: item.category || 'trackable',
      supplier: item.supplier || null,
      expiryDate: item.expiryDate || null,
    };
  },

  async updateFoodItem(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      return await this.getFoodItemById(id);
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const fieldMappings: Record<string, string> = {
      costPrice: 'cost_price', currentStock: 'current_stock', minStockLevel: 'min_stock_level',
      inInventory: 'in_inventory', expiryDate: 'expiry_date'
    };

    for (const [key, value] of Object.entries(updates)) {
      const dbField = fieldMappings[key] || key;
      setClauses.push(`${dbField} = $${paramIndex}`);
      values.push(value);
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE food_items SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    return await this.getFoodItemById(id);
  },

  async deleteFoodItem(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM food_items WHERE id = $1', [id]);
  },

  async adjustStock(foodId: string, quantity: number, type: 'add' | 'remove') {
    const database = await getDatabase();
    const operator = type === 'add' ? '+' : '-';
    await database.execute(
      `UPDATE food_items SET current_stock = current_stock ${operator} $1 WHERE id = $2`,
      [quantity, foodId]
    );
    return await this.getFoodItemById(foodId);
  },

  /* DEVICE CONFIGS */
  async getAllDeviceConfigs() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM device_configs ORDER BY category');
    return (result || []).map(transformDeviceConfigRow);
  },

  async getDeviceConfigById(id: string) {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM device_configs WHERE id = $1', [id]);
    return result[0] ? transformDeviceConfigRow(result[0]) : null;
  },

  async createDeviceConfig(config: any) {
    const database = await getDatabase();
    const id = generateUUID();
    await database.execute(
      'INSERT INTO device_configs (id, category, count, seats) VALUES ($1, $2, $3, $4)',
      [id, config.category, config.count || 0, JSON.stringify(config.seats || [])]
    );
    return {
      id,
      category: config.category,
      count: config.count || 0,
      seats: config.seats || [],
    };
  },

  async updateDeviceConfig(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      return await this.getDeviceConfigById(id);
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    for (const [key, value] of Object.entries(updates)) {
      setClauses.push(`${key} = $${paramIndex}`);
      values.push(key === 'seats' ? JSON.stringify(value) : value);
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE device_configs SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    return await this.getDeviceConfigById(id);
  },

  async deleteDeviceConfig(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM device_configs WHERE id = $1', [id]);
  },

  /* PRICING CONFIGS */
  async getAllPricingConfigs() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM pricing_configs ORDER BY category, duration');
    return (result || []).map(transformPricingConfigRow);
  },

  async getPricingConfigById(id: string) {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM pricing_configs WHERE id = $1', [id]);
    return result[0] ? transformPricingConfigRow(result[0]) : null;
  },

  async createPricingConfig(config: any) {
    const database = await getDatabase();
    const id = generateUUID();
    await database.execute(
      'INSERT INTO pricing_configs (id, category, duration, price, person_count) VALUES ($1, $2, $3, $4, $5)',
      [id, config.category, config.duration, config.price, config.personCount || 1]
    );
    return {
      id,
      category: config.category,
      duration: config.duration,
      price: config.price,
      personCount: config.personCount || 1,
    };
  },

  async updatePricingConfig(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      return await this.getPricingConfigById(id);
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    for (const [key, value] of Object.entries(updates)) {
      const dbField = key === 'personCount' ? 'person_count' : key;
      setClauses.push(`${dbField} = $${paramIndex}`);
      values.push(value);
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE pricing_configs SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    return await this.getPricingConfigById(id);
  },

  async deletePricingConfig(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM pricing_configs WHERE id = $1', [id]);
  },

  /* HAPPY HOURS */
  async getAllHappyHoursConfigs() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM happy_hours_configs');
    return (result || []).map((row: any) => ({
      id: row.id,
      category: row.category,
      startTime: row.start_time,
      endTime: row.end_time,
      enabled: row.enabled
    }));
  },

  async getAllHappyHoursPricing() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM happy_hours_pricing');
    return (result || []).map((row: any) => ({
      id: row.id,
      category: row.category,
      duration: row.duration,
      price: row.price,
      personCount: row.person_count
    }));
  },

  /* EXPENSES */
  async getAllExpenses() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM expenses ORDER BY date DESC');
    return (result || []).map(transformExpenseRow);
  },

  async getExpenseById(id: string) {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM expenses WHERE id = $1', [id]);
    return result[0] ? transformExpenseRow(result[0]) : null;
  },

  async createExpense(expense: any) {
    const database = await getDatabase();
    const id = generateUUID();
    const now = new Date().toISOString();
    await database.execute(
      'INSERT INTO expenses (id, category, description, amount, date, created_at) VALUES ($1, $2, $3, $4, $5, $6)',
      [id, expense.category, expense.description, expense.amount, expense.date, now]
    );
    return {
      id,
      category: expense.category,
      description: expense.description,
      amount: expense.amount,
      date: expense.date,
      createdAt: now,
    };
  },

  async updateExpense(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      return await this.getExpenseById(id);
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    for (const [key, value] of Object.entries(updates)) {
      setClauses.push(`${key} = $${paramIndex}`);
      values.push(value);
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE expenses SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    return await this.getExpenseById(id);
  },

  async deleteExpense(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM expenses WHERE id = $1', [id]);
  },

  /* BOOKING HISTORY */
  async getBookingHistory() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM booking_history ORDER BY archived_at DESC');
    return (result || []).map(transformBookingHistoryRow);
  },

  async archiveBooking(booking: any) {
    const database = await getDatabase();
    const id = generateUUID();
    const now = new Date().toISOString();
    
    await database.execute(
      `INSERT INTO booking_history (
        id, booking_id, booking_code, group_id, group_code, category, seat_number, seat_name,
        customer_name, whatsapp_number, start_time, end_time, price, status,
        booking_type, paused_remaining_time, person_count, payment_method,
        cash_amount, upi_amount, payment_status, last_payment_action, food_orders,
        original_price, discount_applied, bonus_hours_applied, promotion_details,
        is_promotional_discount, is_promotional_bonus, manual_discount_percentage,
        manual_free_hours, discount, bonus, created_at, archived_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35)`,
      [
        id, booking.id, booking.bookingCode, booking.groupId, booking.groupCode,
        booking.category, booking.seatNumber, booking.seatName,
        booking.customerName, booking.whatsappNumber,
        booking.startTime, booking.endTime, booking.price, booking.status,
        JSON.stringify(booking.bookingType || []), booking.pausedRemainingTime,
        booking.personCount, booking.paymentMethod,
        booking.cashAmount, booking.upiAmount, booking.paymentStatus,
        JSON.stringify(booking.lastPaymentAction || null), JSON.stringify(booking.foodOrders || []),
        booking.originalPrice, booking.discountApplied, booking.bonusHoursApplied,
        JSON.stringify(booking.promotionDetails || null), booking.isPromotionalDiscount,
        booking.isPromotionalBonus, booking.manualDiscountPercentage,
        booking.manualFreeHours, booking.discount, booking.bonus,
        booking.createdAt, now
      ]
    );
    
    return { ...booking, id, bookingId: booking.id, archivedAt: now };
  },

  /* USERS */
  async getAllUsers() {
    const database = await getDatabase();
    const result = await database.select('SELECT id, username, role, onboarding_completed, profile_image_url, created_at, updated_at FROM users');
    return (result || []).map(transformUserRow);
  },

  async getUserById(id: string) {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM users WHERE id = $1', [id]);
    return result[0] ? transformUserRow(result[0]) : null;
  },

  async getUserByUsername(username: string) {
    const database = await getDatabase();
    const result = await database.select(
      'SELECT * FROM users WHERE username = $1',
      [username]
    );
    if (!result[0]) return null;
    return {
      ...transformUserRow(result[0]),
      passwordHash: result[0].password_hash,
    };
  },

  async validatePassword(username: string, password: string) {
    const user = await this.getUserByUsername(username);
    if (!user || !user.passwordHash) return null;
    
    const bcrypt = await import('bcryptjs');
    const isValid = await bcrypt.compare(password, user.passwordHash);
    if (!isValid) return null;
    
    const { passwordHash, ...userWithoutPassword } = user;
    return userWithoutPassword;
  },

  async createUser(userData: { username: string; password: string; role: string }) {
    const database = await getDatabase();
    const id = generateUUID();
    const now = new Date().toISOString();
    const bcrypt = await import('bcryptjs');
    const passwordHash = await bcrypt.hash(userData.password, 10);
    
    await database.execute(
      `INSERT INTO users (id, username, password_hash, role, onboarding_completed, created_at, updated_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [id, userData.username, passwordHash, userData.role, 0, now, now]
    );
    
    return {
      id,
      username: userData.username,
      role: userData.role,
      onboardingCompleted: 0,
      profileImageUrl: null,
      createdAt: now,
      updatedAt: now,
    };
  },

  async updateUser(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      return await this.getUserById(id);
    }
    const database = await getDatabase();
    const now = new Date().toISOString();
    const setClauses: string[] = ['updated_at = $1'];
    const values: any[] = [now];
    let paramIndex = 2;

    const fieldMappings: Record<string, string> = {
      onboardingCompleted: 'onboarding_completed',
      profileImageUrl: 'profile_image_url',
    };

    for (const [key, value] of Object.entries(updates)) {
      if (key === 'password') {
        const bcrypt = await import('bcryptjs');
        const passwordHash = await bcrypt.hash(value as string, 10);
        setClauses.push(`password_hash = $${paramIndex}`);
        values.push(passwordHash);
      } else {
        const dbField = fieldMappings[key] || key;
        setClauses.push(`${dbField} = $${paramIndex}`);
        values.push(value);
      }
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE users SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    return await this.getUserById(id);
  },

  async deleteUser(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM users WHERE id = $1', [id]);
  },

  /* ACTIVITY LOGS */
  async getActivityLogs() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM activity_logs ORDER BY created_at DESC LIMIT 1000');
    return (result || []).map(transformActivityLogRow);
  },

  async createActivityLog(log: any) {
    const database = await getDatabase();
    const id = generateUUID();
    const now = new Date().toISOString();
    await database.execute(
      `INSERT INTO activity_logs (id, user_id, username, user_role, action, entity_type, entity_id, details, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [id, log.userId, log.username, log.userRole, log.action, log.entityType || null, log.entityId || null, log.details || null, now]
    );
    return {
      id,
      userId: log.userId,
      username: log.username,
      userRole: log.userRole,
      action: log.action,
      entityType: log.entityType || null,
      entityId: log.entityId || null,
      details: log.details || null,
      createdAt: now,
    };
  },

  /* NOTIFICATIONS */
  async getNotifications() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM notifications ORDER BY created_at DESC LIMIT 100');
    return (result || []).map(transformNotificationRow);
  },

  async getUnreadNotifications() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM notifications WHERE is_read = 0 ORDER BY created_at DESC');
    return (result || []).map(transformNotificationRow);
  },

  async createNotification(notification: any) {
    const database = await getDatabase();
    const id = generateUUID();
    const now = new Date().toISOString();
    await database.execute(
      `INSERT INTO notifications (id, type, title, message, entity_type, entity_id, activity_log_id, is_read, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [id, notification.type, notification.title, notification.message, 
       notification.entityType || null, notification.entityId || null, 
       notification.activityLogId || null, 0, now]
    );
    return {
      id,
      type: notification.type,
      title: notification.title,
      message: notification.message,
      entityType: notification.entityType || null,
      entityId: notification.entityId || null,
      activityLogId: notification.activityLogId || null,
      isRead: 0,
      createdAt: now,
    };
  },

  async markNotificationAsRead(id: string) {
    const database = await getDatabase();
    await database.execute('UPDATE notifications SET is_read = 1 WHERE id = $1', [id]);
  },

  async markAllNotificationsAsRead() {
    const database = await getDatabase();
    await database.execute('UPDATE notifications SET is_read = 1 WHERE is_read = 0');
  },

  /* GAMING CENTER INFO */
  async getGamingCenterInfo() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM gaming_center_info LIMIT 1');
    return result[0] ? transformGamingCenterInfoRow(result[0]) : null;
  },

  async updateGamingCenterInfo(info: any) {
    const database = await getDatabase();
    const existing = await this.getGamingCenterInfo();
    const now = new Date().toISOString();
    
    if (existing) {
      await database.execute(
        `UPDATE gaming_center_info SET name = $1, description = $2, address = $3, phone = $4, email = $5, hours = $6, timezone = $7, updated_at = $8 WHERE id = $9`,
        [info.name, info.description, info.address, info.phone, info.email || null, info.hours, info.timezone || 'Asia/Kolkata', now, existing.id]
      );
      return { ...existing, ...info, updatedAt: now };
    } else {
      const id = generateUUID();
      await database.execute(
        `INSERT INTO gaming_center_info (id, name, description, address, phone, email, hours, timezone, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
        [id, info.name, info.description, info.address, info.phone, info.email || null, info.hours, info.timezone || 'Asia/Kolkata', now]
      );
      return { id, ...info, updatedAt: now };
    }
  },

  /* SESSION GROUPS */
  async getAllSessionGroups() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM session_groups ORDER BY created_at DESC');
    return (result || []).map(transformSessionGroupRow);
  },

  async createSessionGroup(group: any) {
    const database = await getDatabase();
    const id = generateUUID();
    const groupCode = generateCode('GRP');
    const now = new Date().toISOString();
    
    await database.execute(
      `INSERT INTO session_groups (id, group_code, group_name, category, booking_type, created_at)
       VALUES ($1, $2, $3, $4, $5, $6)`,
      [id, groupCode, group.groupName, group.category, JSON.stringify(group.bookingType || []), now]
    );
    
    return {
      id,
      groupCode,
      groupName: group.groupName,
      category: group.category,
      bookingType: group.bookingType || [],
      createdAt: now,
    };
  },

  async deleteSessionGroup(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM session_groups WHERE id = $1', [id]);
  },

  /* STAFF VISIBILITY SETTINGS */
  async getStaffVisibilitySettings() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM staff_visibility_settings LIMIT 1');
    if (!result[0]) return null;
    return {
      id: result[0].id,
      pages: safeJsonParse(result[0].pages, {}),
      dashboard: safeJsonParse(result[0].dashboard, {}),
      updatedAt: result[0].updated_at,
    };
  },

  async updateStaffVisibilitySettings(settings: any) {
    const database = await getDatabase();
    const existing = await this.getStaffVisibilitySettings();
    const now = new Date().toISOString();
    
    if (existing) {
      await database.execute(
        `UPDATE staff_visibility_settings SET pages = $1, dashboard = $2, updated_at = $3 WHERE id = $4`,
        [JSON.stringify(settings.pages || {}), JSON.stringify(settings.dashboard || {}), now, existing.id]
      );
      return { ...existing, ...settings, updatedAt: now };
    } else {
      const id = generateUUID();
      await database.execute(
        `INSERT INTO staff_visibility_settings (id, pages, dashboard, updated_at)
         VALUES ($1, $2, $3, $4)`,
        [id, JSON.stringify(settings.pages || {}), JSON.stringify(settings.dashboard || {}), now]
      );
      return { id, ...settings, updatedAt: now };
    }
  },

  /* APP SETTINGS */
  async getAppSettings() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM app_settings LIMIT 1');
    if (!result[0]) return null;
    return {
      id: result[0].id,
      theme: result[0].theme,
      language: result[0].language,
      notifications: safeJsonParse(result[0].notifications, {}),
      updatedAt: result[0].updated_at,
    };
  },

  async updateAppSettings(settings: any) {
    const database = await getDatabase();
    const existing = await this.getAppSettings();
    const now = new Date().toISOString();
    
    if (existing) {
      await database.execute(
        `UPDATE app_settings SET theme = $1, language = $2, notifications = $3, updated_at = $4 WHERE id = $5`,
        [settings.theme || 'system', settings.language || 'en', JSON.stringify(settings.notifications || {}), now, existing.id]
      );
      return { ...existing, ...settings, updatedAt: now };
    } else {
      const id = generateUUID();
      await database.execute(
        `INSERT INTO app_settings (id, theme, language, notifications, updated_at)
         VALUES ($1, $2, $3, $4, $5)`,
        [id, settings.theme || 'system', settings.language || 'en', JSON.stringify(settings.notifications || {}), now]
      );
      return { id, ...settings, updatedAt: now };
    }
  },

  /* GALLERY IMAGES */
  async getAllGalleryImages() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM gallery_images ORDER BY created_at DESC');
    return (result || []).map((row: any) => ({
      id: row.id,
      title: row.title,
      imageUrl: row.image_url,
      description: row.description,
      createdAt: parseDateRequired(row.created_at),
    }));
  },

  async createGalleryImage(image: any) {
    const database = await getDatabase();
    const id = generateUUID();
    const now = new Date().toISOString();
    await database.execute(
      `INSERT INTO gallery_images (id, title, image_url, description, created_at)
       VALUES ($1, $2, $3, $4, $5)`,
      [id, image.title, image.imageUrl, image.description || null, now]
    );
    return {
      id,
      title: image.title,
      imageUrl: image.imageUrl,
      description: image.description || null,
      createdAt: now,
    };
  },

  async deleteGalleryImage(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM gallery_images WHERE id = $1', [id]);
  },

  /* FACILITIES */
  async getAllFacilities() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM facilities ORDER BY name');
    return (result || []).map((row: any) => ({
      id: row.id,
      name: row.name,
      description: row.description,
      icon: row.icon,
    }));
  },

  async createFacility(facility: any) {
    const database = await getDatabase();
    const id = generateUUID();
    await database.execute(
      `INSERT INTO facilities (id, name, description, icon) VALUES ($1, $2, $3, $4)`,
      [id, facility.name, facility.description, facility.icon]
    );
    return {
      id,
      name: facility.name,
      description: facility.description,
      icon: facility.icon,
    };
  },

  async updateFacility(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      const result = await (await getDatabase()).select('SELECT * FROM facilities WHERE id = $1', [id]);
      return result[0] ? {
        id: result[0].id,
        name: result[0].name,
        description: result[0].description,
        icon: result[0].icon,
      } : null;
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    for (const [key, value] of Object.entries(updates)) {
      setClauses.push(`${key} = $${paramIndex}`);
      values.push(value);
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE facilities SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    const result = await database.select('SELECT * FROM facilities WHERE id = $1', [id]);
    return result[0] ? {
      id: result[0].id,
      name: result[0].name,
      description: result[0].description,
      icon: result[0].icon,
    } : null;
  },

  async deleteFacility(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM facilities WHERE id = $1', [id]);
  },

  /* GAMES */
  async getAllGames() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM games ORDER BY name');
    return (result || []).map((row: any) => ({
      id: row.id,
      name: row.name,
      description: row.description,
      imageUrl: row.image_url,
      category: row.category,
    }));
  },

  async createGame(game: any) {
    const database = await getDatabase();
    const id = generateUUID();
    await database.execute(
      `INSERT INTO games (id, name, description, image_url, category) VALUES ($1, $2, $3, $4, $5)`,
      [id, game.name, game.description || null, game.imageUrl || null, game.category]
    );
    return {
      id,
      name: game.name,
      description: game.description || null,
      imageUrl: game.imageUrl || null,
      category: game.category,
    };
  },

  async updateGame(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      const result = await (await getDatabase()).select('SELECT * FROM games WHERE id = $1', [id]);
      return result[0] ? {
        id: result[0].id,
        name: result[0].name,
        description: result[0].description,
        imageUrl: result[0].image_url,
        category: result[0].category,
      } : null;
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const fieldMappings: Record<string, string> = {
      imageUrl: 'image_url',
    };

    for (const [key, value] of Object.entries(updates)) {
      const dbField = fieldMappings[key] || key;
      setClauses.push(`${dbField} = $${paramIndex}`);
      values.push(value);
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE games SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    const result = await database.select('SELECT * FROM games WHERE id = $1', [id]);
    return result[0] ? {
      id: result[0].id,
      name: result[0].name,
      description: result[0].description,
      imageUrl: result[0].image_url,
      category: result[0].category,
    } : null;
  },

  async deleteGame(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM games WHERE id = $1', [id]);
  },

  /* DEVICE MAINTENANCE */
  async getAllDeviceMaintenance() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM device_maintenance ORDER BY category, seat_name');
    return (result || []).map((row: any) => ({
      id: row.id,
      category: row.category,
      seatName: row.seat_name,
      lastMaintenanceDate: parseDate(row.last_maintenance_date),
      totalUsageHours: row.total_usage_hours,
      totalSessions: row.total_sessions,
      issuesReported: row.issues_reported,
      maintenanceNotes: row.maintenance_notes,
      status: row.status,
      createdAt: parseDateRequired(row.created_at),
      updatedAt: parseDate(row.updated_at),
    }));
  },

  async getDeviceMaintenanceById(id: string) {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM device_maintenance WHERE id = $1', [id]);
    if (!result[0]) return null;
    return {
      id: result[0].id,
      category: result[0].category,
      seatName: result[0].seat_name,
      lastMaintenanceDate: parseDate(result[0].last_maintenance_date),
      totalUsageHours: result[0].total_usage_hours,
      totalSessions: result[0].total_sessions,
      issuesReported: result[0].issues_reported,
      maintenanceNotes: result[0].maintenance_notes,
      status: result[0].status,
      createdAt: parseDateRequired(result[0].created_at),
      updatedAt: parseDate(result[0].updated_at),
    };
  },

  async getDeviceMaintenanceBySeat(category: string, seatName: string) {
    const database = await getDatabase();
    const result = await database.select(
      'SELECT * FROM device_maintenance WHERE category = $1 AND seat_name = $2',
      [category, seatName]
    );
    if (!result[0]) return null;
    return {
      id: result[0].id,
      category: result[0].category,
      seatName: result[0].seat_name,
      lastMaintenanceDate: parseDate(result[0].last_maintenance_date),
      totalUsageHours: result[0].total_usage_hours,
      totalSessions: result[0].total_sessions,
      issuesReported: result[0].issues_reported,
      maintenanceNotes: result[0].maintenance_notes,
      status: result[0].status,
      createdAt: parseDateRequired(result[0].created_at),
      updatedAt: parseDate(result[0].updated_at),
    };
  },

  async upsertDeviceMaintenance(maintenance: any) {
    const database = await getDatabase();
    const now = new Date().toISOString();
    const existing = await this.getDeviceMaintenanceBySeat(maintenance.category, maintenance.seatName);
    
    if (existing) {
      await database.execute(
        `UPDATE device_maintenance SET 
          last_maintenance_date = $1, total_usage_hours = $2, total_sessions = $3,
          issues_reported = $4, maintenance_notes = $5, status = $6, updated_at = $7
         WHERE id = $8`,
        [
          maintenance.lastMaintenanceDate || null,
          maintenance.totalUsageHours || 0,
          maintenance.totalSessions || 0,
          maintenance.issuesReported || 0,
          maintenance.maintenanceNotes || null,
          maintenance.status || 'healthy',
          now,
          existing.id
        ]
      );
      return { ...existing, ...maintenance, updatedAt: now };
    } else {
      const id = generateUUID();
      await database.execute(
        `INSERT INTO device_maintenance (id, category, seat_name, last_maintenance_date, total_usage_hours, total_sessions, issues_reported, maintenance_notes, status, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`,
        [
          id,
          maintenance.category,
          maintenance.seatName,
          maintenance.lastMaintenanceDate || null,
          maintenance.totalUsageHours || 0,
          maintenance.totalSessions || 0,
          maintenance.issuesReported || 0,
          maintenance.maintenanceNotes || null,
          maintenance.status || 'healthy',
          now,
          now
        ]
      );
      return { id, ...maintenance, createdAt: now, updatedAt: now };
    }
  },

  async recordMaintenanceCompleted(id: string, notes?: string) {
    const database = await getDatabase();
    const now = new Date().toISOString();
    await database.execute(
      `UPDATE device_maintenance SET last_maintenance_date = $1, status = 'healthy', maintenance_notes = $2, updated_at = $3 WHERE id = $4`,
      [now, notes || null, now, id]
    );
    return await this.getDeviceMaintenanceById(id);
  },

  /* STOCK BATCHES */
  async getAllStockBatches() {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM stock_batches ORDER BY purchase_date DESC');
    return (result || []).map((row: any) => ({
      id: row.id,
      foodItemId: row.food_item_id,
      quantity: row.quantity,
      costPrice: row.cost_price,
      supplier: row.supplier,
      purchaseDate: parseDateRequired(row.purchase_date),
      expiryDate: parseDate(row.expiry_date),
      notes: row.notes,
      createdAt: parseDateRequired(row.created_at),
    }));
  },

  async getStockBatchesByFoodItem(foodItemId: string) {
    const database = await getDatabase();
    const result = await database.select(
      'SELECT * FROM stock_batches WHERE food_item_id = $1 ORDER BY purchase_date DESC',
      [foodItemId]
    );
    return (result || []).map((row: any) => ({
      id: row.id,
      foodItemId: row.food_item_id,
      quantity: row.quantity,
      costPrice: row.cost_price,
      supplier: row.supplier,
      purchaseDate: parseDateRequired(row.purchase_date),
      expiryDate: parseDate(row.expiry_date),
      notes: row.notes,
      createdAt: parseDateRequired(row.created_at),
    }));
  },

  async createStockBatch(batch: any) {
    const database = await getDatabase();
    const id = generateUUID();
    const now = new Date().toISOString();
    await database.execute(
      `INSERT INTO stock_batches (id, food_item_id, quantity, cost_price, supplier, purchase_date, expiry_date, notes, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [
        id,
        batch.foodItemId,
        batch.quantity,
        batch.costPrice,
        batch.supplier || null,
        batch.purchaseDate || now,
        batch.expiryDate || null,
        batch.notes || null,
        now
      ]
    );
    await this.adjustStock(batch.foodItemId, batch.quantity, 'add');
    return {
      id,
      foodItemId: batch.foodItemId,
      quantity: batch.quantity,
      costPrice: batch.costPrice,
      supplier: batch.supplier || null,
      purchaseDate: batch.purchaseDate || now,
      expiryDate: batch.expiryDate || null,
      notes: batch.notes || null,
      createdAt: now,
    };
  },

  /* UPSERT FUNCTIONS */
  async upsertDeviceConfig(config: any) {
    const database = await getDatabase();
    const result = await database.select('SELECT * FROM device_configs WHERE category = $1', [config.category]);
    
    if (result[0]) {
      return await this.updateDeviceConfig(result[0].id, {
        count: config.count,
        seats: config.seats,
      });
    } else {
      return await this.createDeviceConfig(config);
    }
  },

  async upsertPricingConfigs(configs: any[]) {
    const results = [];
    for (const config of configs) {
      const database = await getDatabase();
      const result = await database.select(
        'SELECT * FROM pricing_configs WHERE category = $1 AND duration = $2 AND person_count = $3',
        [config.category, config.duration, config.personCount || 1]
      );
      
      if (result[0]) {
        const updated = await this.updatePricingConfig(result[0].id, { price: config.price });
        results.push(updated);
      } else {
        const created = await this.createPricingConfig(config);
        results.push(created);
      }
    }
    return results;
  },

  async upsertHappyHoursConfigs(configs: any[]) {
    const database = await getDatabase();
    const existingConfigs = await database.select('SELECT * FROM happy_hours_configs');
    
    try {
      await database.execute('DELETE FROM happy_hours_configs');
      
      const results = [];
      for (const config of configs) {
        const id = generateUUID();
        await database.execute(
          `INSERT INTO happy_hours_configs (id, category, start_time, end_time, enabled)
           VALUES ($1, $2, $3, $4, $5)`,
          [id, config.category, config.startTime, config.endTime, config.enabled ? 1 : 0]
        );
        results.push({ id, ...config });
      }
      return results;
    } catch (error) {
      console.error('[DB] upsertHappyHoursConfigs failed, attempting to restore previous data:', error);
      try {
        for (const existing of existingConfigs || []) {
          await database.execute(
            `INSERT INTO happy_hours_configs (id, category, start_time, end_time, enabled)
             VALUES ($1, $2, $3, $4, $5)`,
            [existing.id, existing.category, existing.start_time, existing.end_time, existing.enabled]
          );
        }
      } catch (restoreError) {
        console.error('[DB] Failed to restore happy hours configs:', restoreError);
      }
      throw error;
    }
  },

  async upsertHappyHoursPricing(pricings: any[]) {
    const database = await getDatabase();
    const existingPricings = await database.select('SELECT * FROM happy_hours_pricing');
    
    try {
      await database.execute('DELETE FROM happy_hours_pricing');
      
      const results = [];
      for (const pricing of pricings) {
        const id = generateUUID();
        await database.execute(
          `INSERT INTO happy_hours_pricing (id, category, duration, price, person_count)
           VALUES ($1, $2, $3, $4, $5)`,
          [id, pricing.category, pricing.duration, pricing.price, pricing.personCount || 1]
        );
        results.push({ id, ...pricing });
      }
      return results;
    } catch (error) {
      console.error('[DB] upsertHappyHoursPricing failed, attempting to restore previous data:', error);
      try {
        for (const existing of existingPricings || []) {
          await database.execute(
            `INSERT INTO happy_hours_pricing (id, category, duration, price, person_count)
             VALUES ($1, $2, $3, $4, $5)`,
            [existing.id, existing.category, existing.duration, existing.price, existing.person_count]
          );
        }
      } catch (restoreError) {
        console.error('[DB] Failed to restore happy hours pricing:', restoreError);
      }
      throw error;
    }
  },

  async deleteAllPricingConfigsByCategory(category: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM pricing_configs WHERE category = $1', [category]);
  },

  async deleteAllHappyHoursPricingByCategory(category: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM happy_hours_pricing WHERE category = $1', [category]);
  },

  /* HAPPY HOURS STATUS */
  async isHappyHoursActive(category?: string) {
    const configs = await this.getAllHappyHoursConfigs();
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    
    const activeConfigs = configs.filter((config: any) => {
      if (!config.enabled) return false;
      if (category && config.category !== category) return false;
      
      const startMinutes = parseTimeToMinutes(config.startTime);
      const endMinutes = parseTimeToMinutes(config.endTime);
      
      return currentMinutes >= startMinutes && currentMinutes <= endMinutes;
    });
    
    return activeConfigs.length > 0;
  },

  async isHappyHoursActiveForTime(time: Date, category?: string) {
    const configs = await this.getAllHappyHoursConfigs();
    const checkMinutes = time.getHours() * 60 + time.getMinutes();
    
    const activeConfigs = configs.filter((config: any) => {
      if (!config.enabled) return false;
      if (category && config.category !== category) return false;
      
      const startMinutes = parseTimeToMinutes(config.startTime);
      const endMinutes = parseTimeToMinutes(config.endTime);
      
      return checkMinutes >= startMinutes && checkMinutes <= endMinutes;
    });
    
    return activeConfigs.length > 0;
  },

  /* INVENTORY FUNCTIONS */
  async getLowStockItems() {
    const database = await getDatabase();
    const result = await database.select(
      'SELECT * FROM food_items WHERE current_stock <= min_stock_level AND in_inventory = 1 ORDER BY current_stock'
    );
    return (result || []).map(transformFoodItemRow);
  },

  async getInventoryItems() {
    const database = await getDatabase();
    const result = await database.select(
      'SELECT * FROM food_items WHERE in_inventory = 1 ORDER BY name'
    );
    return (result || []).map(transformFoodItemRow);
  },

  async getReorderList() {
    const database = await getDatabase();
    const result = await database.select(
      'SELECT * FROM food_items WHERE current_stock <= min_stock_level AND in_inventory = 1 ORDER BY (min_stock_level - current_stock) DESC'
    );
    return (result || []).map(transformFoodItemRow);
  },

  async getExpiringItems(daysAhead: number = 7) {
    const database = await getDatabase();
    const futureDate = new Date();
    futureDate.setDate(futureDate.getDate() + daysAhead);
    const result = await database.select(
      `SELECT * FROM food_items WHERE expiry_date IS NOT NULL AND expiry_date <= $1 AND in_inventory = 1 ORDER BY expiry_date`,
      [futureDate.toISOString()]
    );
    return (result || []).map(transformFoodItemRow);
  },

  async addToInventory(foodItemId: string) {
    const database = await getDatabase();
    await database.execute('UPDATE food_items SET in_inventory = 1 WHERE id = $1', [foodItemId]);
    return await this.getFoodItemById(foodItemId);
  },

  async removeFromInventory(foodItemId: string) {
    const database = await getDatabase();
    await database.execute('UPDATE food_items SET in_inventory = 0 WHERE id = $1', [foodItemId]);
    return await this.getFoodItemById(foodItemId);
  },

  /* NOTIFICATION FUNCTIONS */
  async deleteNotification(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM notifications WHERE id = $1', [id]);
  },

  async getUnreadNotificationCount() {
    const database = await getDatabase();
    const result = await database.select('SELECT COUNT(*) as count FROM notifications WHERE is_read = 0');
    return result[0]?.count || 0;
  },

  async clearAllNotifications() {
    const database = await getDatabase();
    await database.execute('DELETE FROM notifications');
  },

  /* BOOKING STATISTICS */
  async getBookingStats(startDate?: string, endDate?: string) {
    const database = await getDatabase();
    let query = 'SELECT * FROM booking_history';
    const params: any[] = [];
    
    if (startDate && endDate) {
      query += ' WHERE created_at >= $1 AND created_at <= $2';
      params.push(startDate, endDate);
    } else if (startDate) {
      query += ' WHERE created_at >= $1';
      params.push(startDate);
    } else if (endDate) {
      query += ' WHERE created_at <= $1';
      params.push(endDate);
    }
    
    const result = await database.select(query, params);
    const history = (result || []).map(transformBookingHistoryRow);
    
    const totalBookings = history.length;
    const totalRevenue = history.reduce((sum: number, b: any) => sum + (parseFloat(b.price) || 0), 0);
    const avgDuration = history.length > 0
      ? history.reduce((sum: number, b: any) => {
          const start = new Date(b.startTime).getTime();
          const end = new Date(b.endTime).getTime();
          return sum + (end - start) / (1000 * 60);
        }, 0) / history.length
      : 0;
    
    const categoryStats: Record<string, { count: number; revenue: number }> = {};
    for (const booking of history) {
      if (!categoryStats[booking.category]) {
        categoryStats[booking.category] = { count: 0, revenue: 0 };
      }
      categoryStats[booking.category].count++;
      categoryStats[booking.category].revenue += parseFloat(booking.price) || 0;
    }
    
    return {
      totalBookings,
      totalRevenue,
      avgDuration: Math.round(avgDuration),
      categoryStats,
      bookings: history,
    };
  },

  async getRetentionMetrics() {
    const database = await getDatabase();
    const result = await database.select('SELECT customer_name, whatsapp_number, COUNT(*) as visit_count FROM booking_history GROUP BY customer_name, whatsapp_number');
    
    const customers = result || [];
    const totalCustomers = customers.length;
    const repeatCustomers = customers.filter((c: any) => c.visit_count > 1).length;
    const retentionRate = totalCustomers > 0 ? (repeatCustomers / totalCustomers) * 100 : 0;
    
    return {
      totalCustomers,
      repeatCustomers,
      retentionRate: Math.round(retentionRate * 100) / 100,
      customerVisits: customers.map((c: any) => ({
        customerName: c.customer_name,
        whatsappNumber: c.whatsapp_number,
        visitCount: c.visit_count,
      })),
    };
  },

  /* REPORTS */
  async getFilteredBookingHistory(filters: { startDate?: string; endDate?: string; category?: string; status?: string }) {
    const database = await getDatabase();
    let query = 'SELECT * FROM booking_history WHERE 1=1';
    const params: any[] = [];
    let paramIndex = 1;
    
    if (filters.startDate) {
      query += ` AND created_at >= $${paramIndex}`;
      params.push(filters.startDate);
      paramIndex++;
    }
    if (filters.endDate) {
      query += ` AND created_at <= $${paramIndex}`;
      params.push(filters.endDate);
      paramIndex++;
    }
    if (filters.category) {
      query += ` AND category = $${paramIndex}`;
      params.push(filters.category);
      paramIndex++;
    }
    if (filters.status) {
      query += ` AND status = $${paramIndex}`;
      params.push(filters.status);
      paramIndex++;
    }
    
    query += ' ORDER BY archived_at DESC';
    
    const result = await database.select(query, params);
    return (result || []).map(transformBookingHistoryRow);
  },

  async getDailyRevenue(date: string) {
    const database = await getDatabase();
    const startOfDay = date + 'T00:00:00.000Z';
    const endOfDay = date + 'T23:59:59.999Z';
    
    const result = await database.select(
      `SELECT SUM(CAST(price AS REAL)) as total FROM booking_history WHERE archived_at >= $1 AND archived_at <= $2`,
      [startOfDay, endOfDay]
    );
    
    return result[0]?.total || 0;
  },

  async getMonthlyRevenue(year: number, month: number) {
    const database = await getDatabase();
    const startOfMonth = `${year}-${String(month).padStart(2, '0')}-01T00:00:00.000Z`;
    const nextMonth = month === 12 ? 1 : month + 1;
    const nextYear = month === 12 ? year + 1 : year;
    const endOfMonth = `${nextYear}-${String(nextMonth).padStart(2, '0')}-01T00:00:00.000Z`;
    
    const result = await database.select(
      `SELECT SUM(CAST(price AS REAL)) as total FROM booking_history WHERE archived_at >= $1 AND archived_at < $2`,
      [startOfMonth, endOfMonth]
    );
    
    return result[0]?.total || 0;
  },

  /* HAPPY HOURS CONFIG CRUD */
  async createHappyHoursConfig(config: any) {
    const database = await getDatabase();
    const id = generateUUID();
    await database.execute(
      `INSERT INTO happy_hours_configs (id, category, start_time, end_time, enabled)
       VALUES ($1, $2, $3, $4, $5)`,
      [id, config.category, config.startTime, config.endTime, config.enabled ? 1 : 0]
    );
    return { id, ...config };
  },

  async updateHappyHoursConfig(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      const result = await (await getDatabase()).select('SELECT * FROM happy_hours_configs WHERE id = $1', [id]);
      return result[0] ? {
        id: result[0].id,
        category: result[0].category,
        startTime: result[0].start_time,
        endTime: result[0].end_time,
        enabled: result[0].enabled,
      } : null;
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const fieldMappings: Record<string, string> = {
      startTime: 'start_time',
      endTime: 'end_time',
    };

    for (const [key, value] of Object.entries(updates)) {
      const dbField = fieldMappings[key] || key;
      setClauses.push(`${dbField} = $${paramIndex}`);
      values.push(key === 'enabled' ? (value ? 1 : 0) : value);
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE happy_hours_configs SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    
    const result = await database.select('SELECT * FROM happy_hours_configs WHERE id = $1', [id]);
    return result[0] ? {
      id: result[0].id,
      category: result[0].category,
      startTime: result[0].start_time,
      endTime: result[0].end_time,
      enabled: result[0].enabled,
    } : null;
  },

  async deleteHappyHoursConfig(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM happy_hours_configs WHERE id = $1', [id]);
  },

  /* HAPPY HOURS PRICING CRUD */
  async createHappyHoursPricing(pricing: any) {
    const database = await getDatabase();
    const id = generateUUID();
    await database.execute(
      `INSERT INTO happy_hours_pricing (id, category, duration, price, person_count)
       VALUES ($1, $2, $3, $4, $5)`,
      [id, pricing.category, pricing.duration, pricing.price, pricing.personCount || 1]
    );
    return {
      id,
      category: pricing.category,
      duration: pricing.duration,
      price: pricing.price,
      personCount: pricing.personCount || 1,
    };
  },

  async updateHappyHoursPricing(id: string, updates: any) {
    if (!updates || Object.keys(updates).length === 0) {
      const result = await (await getDatabase()).select('SELECT * FROM happy_hours_pricing WHERE id = $1', [id]);
      return result[0] ? {
        id: result[0].id,
        category: result[0].category,
        duration: result[0].duration,
        price: result[0].price,
        personCount: result[0].person_count,
      } : null;
    }
    const database = await getDatabase();
    const setClauses: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const fieldMappings: Record<string, string> = {
      personCount: 'person_count',
    };

    for (const [key, value] of Object.entries(updates)) {
      const dbField = fieldMappings[key] || key;
      setClauses.push(`${dbField} = $${paramIndex}`);
      values.push(value);
      paramIndex++;
    }

    values.push(id);
    await database.execute(
      `UPDATE happy_hours_pricing SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    
    const result = await database.select('SELECT * FROM happy_hours_pricing WHERE id = $1', [id]);
    return result[0] ? {
      id: result[0].id,
      category: result[0].category,
      duration: result[0].duration,
      price: result[0].price,
      personCount: result[0].person_count,
    } : null;
  },

  async deleteHappyHoursPricing(id: string) {
    const database = await getDatabase();
    await database.execute('DELETE FROM happy_hours_pricing WHERE id = $1', [id]);
  },

  /* ARCHIVE EXPIRED BOOKINGS */
  async archiveExpiredBookings() {
    const database = await getDatabase();
    const now = new Date().toISOString();
    
    // Get all expired bookings (end_time has passed and status is 'running' or 'expired')
    const expiredBookings = await database.select(
      `SELECT * FROM bookings WHERE end_time < $1 AND status IN ('running', 'expired', 'completed')`,
      [now]
    );
    
    let count = 0;
    for (const row of expiredBookings) {
      const booking = transformBookingRow(row);
      
      // Archive the booking
      const id = generateUUID();
      await database.execute(
        `INSERT INTO booking_history (
          id, booking_id, booking_code, group_id, group_code, category, seat_number, seat_name,
          customer_name, whatsapp_number, start_time, end_time, price, status,
          booking_type, paused_remaining_time, person_count, payment_method,
          cash_amount, upi_amount, payment_status, last_payment_action, food_orders,
          original_price, discount_applied, bonus_hours_applied, promotion_details,
          is_promotional_discount, is_promotional_bonus, manual_discount_percentage,
          manual_free_hours, discount, bonus, created_at, archived_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35)`,
        [
          id, booking.id, booking.bookingCode, booking.groupId, booking.groupCode,
          booking.category, booking.seatNumber, booking.seatName,
          booking.customerName, booking.whatsappNumber,
          booking.startTime, booking.endTime, booking.price, 'expired',
          JSON.stringify(booking.bookingType || []), booking.pausedRemainingTime,
          booking.personCount, booking.paymentMethod,
          booking.cashAmount, booking.upiAmount, booking.paymentStatus,
          JSON.stringify(booking.lastPaymentAction || null), JSON.stringify(booking.foodOrders || []),
          booking.originalPrice, booking.discountApplied, booking.bonusHoursApplied,
          JSON.stringify(booking.promotionDetails || null), booking.isPromotionalDiscount ? 1 : 0,
          booking.isPromotionalBonus ? 1 : 0, booking.manualDiscountPercentage,
          booking.manualFreeHours, booking.discount, booking.bonus,
          booking.createdAt, now
        ]
      );
      
      // Delete from active bookings
      await database.execute('DELETE FROM bookings WHERE id = $1', [booking.id]);
      count++;
    }
    
    return { count };
  },

  /* ANALYTICS */
  async getAnalyticsUsage(timeRange: string) {
    const database = await getDatabase();
    
    // Get device configs for total capacity
    const deviceConfigs = await database.select('SELECT * FROM device_configs');
    const totalCapacity = deviceConfigs.reduce((sum: number, config: any) => sum + (config.count || 0), 0);
    
    // Get active bookings count
    const activeBookings = await database.select(
      "SELECT COUNT(*) as count FROM bookings WHERE status IN ('running', 'paused')"
    );
    const activeCount = activeBookings[0]?.count || 0;
    
    // Get category usage
    const categoryUsage: any[] = [];
    for (const config of deviceConfigs) {
      const category = config.category;
      const total = config.count || 0;
      const occupiedResult = await database.select(
        `SELECT COUNT(*) as count FROM bookings WHERE category = $1 AND status IN ('running', 'paused')`,
        [category]
      );
      const occupied = occupiedResult[0]?.count || 0;
      categoryUsage.push({
        category,
        occupied,
        total,
        percentage: total > 0 ? Math.round((occupied / total) * 100) : 0
      });
    }
    
    // Get hourly usage (last 24 hours for simplicity)
    const hourlyUsage: any[] = [];
    for (let i = 0; i < 24; i++) {
      const hour = i.toString().padStart(2, '0') + ':00';
      hourlyUsage.push({
        hour,
        bookings: 0,
        revenue: 0
      });
    }
    
    // Get booking history for revenue data
    const bookingHistory = await database.select('SELECT * FROM booking_history');
    bookingHistory.forEach((booking: any) => {
      const startTime = new Date(booking.start_time);
      const hour = startTime.getHours();
      if (hourlyUsage[hour]) {
        hourlyUsage[hour].bookings++;
        hourlyUsage[hour].revenue += parseFloat(booking.price) || 0;
      }
    });
    
    // Get unique customers
    const uniqueCustomersResult = await database.select(
      'SELECT COUNT(DISTINCT customer_name) as count FROM booking_history WHERE customer_name IS NOT NULL'
    );
    const uniqueCustomers = uniqueCustomersResult[0]?.count || 0;
    
    // Get food orders stats
    const allBookings = await database.select('SELECT food_orders FROM bookings');
    const historyBookings = await database.select('SELECT food_orders FROM booking_history');
    
    let totalFoodOrders = 0;
    let foodRevenue = 0;
    
    [...allBookings, ...historyBookings].forEach((booking: any) => {
      const orders = safeJsonParse(booking.food_orders, []);
      orders.forEach((order: any) => {
        totalFoodOrders += order.quantity || 1;
        foodRevenue += (parseFloat(order.price) || 0) * (order.quantity || 1);
      });
    });
    
    return {
      currentOccupancy: activeCount,
      totalCapacity,
      occupancyRate: totalCapacity > 0 ? Math.round((activeCount / totalCapacity) * 100) : 0,
      activeBookings: activeCount,
      categoryUsage,
      hourlyUsage,
      realtimeData: [],
      uniqueCustomers,
      avgSessionDuration: 60,
      totalFoodOrders,
      foodRevenue
    };
  },

  async getTrafficPredictions() {
    const predictions = [];
    for (let i = 8; i <= 23; i++) {
      predictions.push({
        hour: `${i.toString().padStart(2, '0')}:00`,
        predictedVisitors: Math.floor(Math.random() * 20) + 5,
        confidence: 'medium' as const
      });
    }
    
    const peakPrediction = predictions.reduce((max, p) => p.predictedVisitors > max.predictedVisitors ? p : max, predictions[0]);
    
    return {
      predictions,
      summary: {
        peakHour: peakPrediction.hour,
        peakVisitors: peakPrediction.predictedVisitors,
        totalPredictedVisitors: predictions.reduce((sum, p) => sum + p.predictedVisitors, 0),
        averageVisitors: Math.round(predictions.reduce((sum, p) => sum + p.predictedVisitors, 0) / predictions.length),
        insights: ['Based on historical patterns', 'Peak hours expected in evening']
      },
      generatedAt: new Date().toISOString()
    };
  },

  /* REPORTS PAGE FUNCTIONS */
  async getReportsStats(period: string, startDate?: string, endDate?: string) {
    const database = await getDatabase();
    
    // Determine date range based on period
    const now = new Date();
    let queryStartDate: string;
    let queryEndDate: string = now.toISOString();
    
    if (period === 'daily') {
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      queryStartDate = todayStart.toISOString();
    } else if (period === 'weekly' && startDate && endDate) {
      queryStartDate = new Date(startDate).toISOString();
      queryEndDate = new Date(endDate + 'T23:59:59.999Z').toISOString();
    } else if (period === 'monthly' && startDate && endDate) {
      queryStartDate = new Date(startDate).toISOString();
      queryEndDate = new Date(endDate + 'T23:59:59.999Z').toISOString();
    } else {
      // Default to today
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      queryStartDate = todayStart.toISOString();
    }
    
    // Query booking history for the period
    const result = await database.select(
      `SELECT * FROM booking_history WHERE archived_at >= $1 AND archived_at <= $2`,
      [queryStartDate, queryEndDate]
    );
    
    const history = (result || []).map(transformBookingHistoryRow);
    
    let totalRevenue = 0;
    let totalFoodRevenue = 0;
    let cashRevenue = 0;
    let upiRevenue = 0;
    let totalDurationMinutes = 0;
    
    for (const booking of history) {
      const price = parseFloat(booking.price) || 0;
      totalRevenue += price;
      
      // Calculate food revenue from food orders
      const foodOrders = booking.foodOrders || [];
      for (const order of foodOrders) {
        totalFoodRevenue += (parseFloat(order.price) || 0) * (order.quantity || 1);
      }
      
      // Calculate payment method breakdown
      if (booking.cashAmount) {
        cashRevenue += parseFloat(booking.cashAmount) || 0;
      } else if (booking.paymentMethod === 'cash') {
        cashRevenue += price;
      }
      
      if (booking.upiAmount) {
        upiRevenue += parseFloat(booking.upiAmount) || 0;
      } else if (booking.paymentMethod === 'upi_online') {
        upiRevenue += price;
      }
      
      // Calculate session duration
      const start = new Date(booking.startTime).getTime();
      const end = new Date(booking.endTime).getTime();
      totalDurationMinutes += (end - start) / (1000 * 60);
    }
    
    const avgSessionMinutes = history.length > 0 ? totalDurationMinutes / history.length : 0;
    
    return {
      totalRevenue,
      totalFoodRevenue,
      totalSessions: history.length,
      avgSessionMinutes: Math.round(avgSessionMinutes),
      cashRevenue,
      upiRevenue
    };
  },

  async getReportsHistory(period: string, startDate?: string, endDate?: string) {
    const database = await getDatabase();
    
    // Determine date range based on period
    const now = new Date();
    let queryStartDate: string;
    let queryEndDate: string = now.toISOString();
    
    if (period === 'daily') {
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      queryStartDate = todayStart.toISOString();
    } else if ((period === 'weekly' || period === 'monthly') && startDate && endDate) {
      queryStartDate = new Date(startDate).toISOString();
      queryEndDate = new Date(endDate + 'T23:59:59.999Z').toISOString();
    } else {
      const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      queryStartDate = todayStart.toISOString();
    }
    
    const result = await database.select(
      `SELECT * FROM booking_history WHERE archived_at >= $1 AND archived_at <= $2 ORDER BY archived_at DESC`,
      [queryStartDate, queryEndDate]
    );
    
    const history = (result || []).map(transformBookingHistoryRow);
    
    // Transform to the format expected by Reports.tsx
    return history.map((booking: any) => {
      const foodOrders = booking.foodOrders || [];
      const foodAmount = foodOrders.reduce((sum: number, order: any) => 
        sum + (parseFloat(order.price) || 0) * (order.quantity || 1), 0
      );
      
      const start = new Date(booking.startTime);
      const end = new Date(booking.endTime);
      const durationMs = end.getTime() - start.getTime();
      const hours = Math.floor(durationMs / (1000 * 60 * 60));
      const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
      const duration = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
      
      return {
        id: booking.id,
        date: booking.archivedAt || booking.createdAt,
        seatName: booking.seatName,
        customerName: booking.customerName,
        duration,
        price: String(booking.price || 0),
        foodAmount,
        totalAmount: (parseFloat(booking.price) || 0) + foodAmount,
        paymentMethod: booking.paymentMethod,
        paymentStatus: booking.paymentStatus || 'unpaid',
        cashAmount: booking.cashAmount ? String(booking.cashAmount) : null,
        upiAmount: booking.upiAmount ? String(booking.upiAmount) : null,
        discount: booking.discount ? String(booking.discount) : null,
        bonus: booking.bonus ? String(booking.bonus) : null,
        discountApplied: booking.discountApplied ? String(booking.discountApplied) : null,
        bonusHoursApplied: booking.bonusHoursApplied ? String(booking.bonusHoursApplied) : null
      };
    });
  },

  /* AI MAINTENANCE FUNCTIONS */
  async getMaintenancePredictions() {
    const database = await getDatabase();
    
    // Get device configs
    const deviceConfigs = await database.select('SELECT * FROM device_configs ORDER BY category');
    const configs = (deviceConfigs || []).map(transformDeviceConfigRow);
    
    // Get booking history for usage metrics
    const bookingHistory = await database.select('SELECT * FROM booking_history');
    const history = (bookingHistory || []).map(transformBookingHistoryRow);
    
    // Get device maintenance records if table exists
    let maintenanceRecords: any[] = [];
    try {
      const maintenanceResult = await database.select('SELECT * FROM device_maintenance');
      maintenanceRecords = maintenanceResult || [];
    } catch {
      // Table might not exist yet
    }
    
    const predictions: any[] = [];
    
    for (const config of configs) {
      const seats = config.seats || [];
      
      for (const seat of seats) {
        const seatName = typeof seat === 'string' ? seat : seat.name || seat;
        
        // Calculate metrics for this device
        const deviceBookings = history.filter((b: any) => 
          b.category === config.category && b.seatName === seatName
        );
        
        const totalSessions = deviceBookings.length;
        let usageHours = 0;
        
        for (const booking of deviceBookings) {
          const start = new Date(booking.startTime).getTime();
          const end = new Date(booking.endTime).getTime();
          usageHours += (end - start) / (1000 * 60 * 60);
        }
        
        // Find maintenance record for this device
        const maintenanceRecord = maintenanceRecords.find((m: any) => 
          m.category === config.category && m.seat_name === seatName
        );
        
        const issuesReported = maintenanceRecord?.issues_count || 0;
        let daysSinceLastMaintenance: number | null = null;
        
        if (maintenanceRecord?.last_maintenance_date) {
          const lastMaintenance = new Date(maintenanceRecord.last_maintenance_date);
          const now = new Date();
          daysSinceLastMaintenance = Math.floor((now.getTime() - lastMaintenance.getTime()) / (1000 * 60 * 60 * 24));
        }
        
        // Calculate risk level based on metrics
        let riskLevel: 'low' | 'medium' | 'high' = 'low';
        let reasoning = 'Device is operating within normal parameters.';
        let recommendedAction = 'Continue regular monitoring.';
        let estimatedDaysUntilMaintenance = 90;
        
        // Risk scoring
        const usageScore = usageHours > 500 ? 3 : usageHours > 200 ? 2 : 1;
        const sessionScore = totalSessions > 100 ? 3 : totalSessions > 50 ? 2 : 1;
        const issueScore = issuesReported > 3 ? 3 : issuesReported > 1 ? 2 : 1;
        const maintenanceScore = daysSinceLastMaintenance === null ? 2 :
          daysSinceLastMaintenance > 60 ? 3 : daysSinceLastMaintenance > 30 ? 2 : 1;
        
        const totalScore = usageScore + sessionScore + issueScore + maintenanceScore;
        
        if (totalScore >= 10) {
          riskLevel = 'high';
          reasoning = `High usage (${usageHours.toFixed(0)}h) with ${issuesReported} reported issues. ${daysSinceLastMaintenance ? `Last serviced ${daysSinceLastMaintenance} days ago.` : 'No maintenance history.'}`;
          recommendedAction = 'Schedule immediate maintenance check.';
          estimatedDaysUntilMaintenance = 7;
        } else if (totalScore >= 7) {
          riskLevel = 'medium';
          reasoning = `Moderate usage (${usageHours.toFixed(0)}h) with ${totalSessions} sessions. Consider preventive maintenance.`;
          recommendedAction = 'Plan maintenance within next 2-4 weeks.';
          estimatedDaysUntilMaintenance = 21;
        } else {
          reasoning = `Normal usage (${usageHours.toFixed(0)}h). Device health appears stable.`;
          recommendedAction = 'Continue regular monitoring.';
          estimatedDaysUntilMaintenance = 60;
        }
        
        predictions.push({
          category: config.category,
          seatName,
          riskLevel,
          recommendedAction,
          estimatedDaysUntilMaintenance,
          reasoning,
          metrics: {
            usageHours: Math.round(usageHours * 10) / 10,
            totalSessions,
            issuesReported,
            daysSinceLastMaintenance
          }
        });
      }
    }
    
    // Sort predictions by risk level (high first)
    predictions.sort((a, b) => {
      const riskOrder = { high: 0, medium: 1, low: 2 };
      return riskOrder[a.riskLevel as keyof typeof riskOrder] - riskOrder[b.riskLevel as keyof typeof riskOrder];
    });
    
    const highRiskDevices = predictions.filter(p => p.riskLevel === 'high').length;
    const mediumRiskDevices = predictions.filter(p => p.riskLevel === 'medium').length;
    const lowRiskDevices = predictions.filter(p => p.riskLevel === 'low').length;
    
    const recommendedActions: string[] = [];
    if (highRiskDevices > 0) {
      recommendedActions.push(`${highRiskDevices} device(s) require immediate attention`);
    }
    if (mediumRiskDevices > 0) {
      recommendedActions.push(`Schedule preventive maintenance for ${mediumRiskDevices} device(s)`);
    }
    
    return {
      predictions,
      summary: {
        highRiskDevices,
        mediumRiskDevices,
        lowRiskDevices,
        totalDevices: predictions.length,
        recommendedActions
      },
      generatedAt: new Date().toISOString()
    };
  },

  async updateDeviceMaintenanceStatus(category: string, seatName: string, status: string, notes?: string) {
    const database = await getDatabase();
    const now = new Date().toISOString();
    
    // Check if device_maintenance table exists, create if not
    try {
      await database.execute(`
        CREATE TABLE IF NOT EXISTS device_maintenance (
          id TEXT PRIMARY KEY,
          category TEXT NOT NULL,
          seat_name TEXT NOT NULL,
          status TEXT DEFAULT 'healthy',
          last_maintenance_date TEXT,
          issues_count INTEGER DEFAULT 0,
          notes TEXT,
          updated_at TEXT
        )
      `);
    } catch {
      // Table might already exist
    }
    
    // Check if record exists
    const existing = await database.select(
      'SELECT * FROM device_maintenance WHERE category = $1 AND seat_name = $2',
      [category, seatName]
    );
    
    if (existing && existing.length > 0) {
      // Update existing record
      await database.execute(
        `UPDATE device_maintenance SET status = $1, last_maintenance_date = $2, notes = $3, updated_at = $4 
         WHERE category = $5 AND seat_name = $6`,
        [status, now, notes || null, now, category, seatName]
      );
    } else {
      // Create new record
      const id = generateUUID();
      await database.execute(
        `INSERT INTO device_maintenance (id, category, seat_name, status, last_maintenance_date, notes, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7)`,
        [id, category, seatName, status, now, notes || null, now]
      );
    }
    
    return { success: true, category, seatName, status };
  },

  async reportDeviceIssue(category: string, seatName: string, issueType: string) {
    const database = await getDatabase();
    const now = new Date().toISOString();
    
    // Ensure table exists
    try {
      await database.execute(`
        CREATE TABLE IF NOT EXISTS device_maintenance (
          id TEXT PRIMARY KEY,
          category TEXT NOT NULL,
          seat_name TEXT NOT NULL,
          status TEXT DEFAULT 'healthy',
          last_maintenance_date TEXT,
          issues_count INTEGER DEFAULT 0,
          notes TEXT,
          updated_at TEXT
        )
      `);
    } catch {
      // Table might already exist
    }
    
    // Check if record exists
    const existing = await database.select(
      'SELECT * FROM device_maintenance WHERE category = $1 AND seat_name = $2',
      [category, seatName]
    );
    
    if (existing && existing.length > 0) {
      // Increment issues count
      await database.execute(
        `UPDATE device_maintenance SET issues_count = issues_count + 1, status = $1, updated_at = $2 
         WHERE category = $3 AND seat_name = $4`,
        [issueType === 'repair' ? 'needs_repair' : 'has_glitch', now, category, seatName]
      );
    } else {
      // Create new record with issue
      const id = generateUUID();
      await database.execute(
        `INSERT INTO device_maintenance (id, category, seat_name, status, issues_count, updated_at)
         VALUES ($1, $2, $3, $4, 1, $5)`,
        [id, category, seatName, issueType === 'repair' ? 'needs_repair' : 'has_glitch', now]
      );
    }
    
    // Generate AI suggestion based on issue type
    let aiSuggestion = 'Issue has been recorded. The device will be flagged for attention.';
    if (issueType === 'repair') {
      aiSuggestion = 'Repair issue logged. Consider scheduling a technician visit soon.';
    } else if (issueType === 'glitch') {
      aiSuggestion = 'Glitch reported. Try restarting the device. If issue persists, schedule maintenance.';
    }
    
    return { success: true, category, seatName, issueType, aiSuggestion };
  },

  async getAvailableSeats(date?: string, timeSlot?: string, durationMinutes?: number) {
    // Get all device configs
    const deviceConfigs = await this.getAllDeviceConfigs();
    
    // Helper function to extract seat numbers from config.seats array OR generate from count
    // Seats can be: number, { number: N }, { seatNumber: N }, or { name: "Seat 1" }
    const extractSeatNumbers = (config: any): number[] => {
      const seats = config.seats;
      const count = config.count || 0;
      
      // If seats array exists and has items, extract from it
      if (Array.isArray(seats) && seats.length > 0) {
        const extracted = seats.map((s: any) => {
          if (typeof s === 'number') return s;
          if (typeof s === 'object' && s !== null) {
            if (typeof s.number === 'number') return s.number;
            if (typeof s.seatNumber === 'number') return s.seatNumber;
            // Try to extract number from seat name like "Seat 1"
            if (typeof s.name === 'string') {
              const match = s.name.match(/(\d+)/);
              if (match) return parseInt(match[1], 10);
            }
          }
          return null;
        }).filter((n): n is number => n !== null);
        
        if (extracted.length > 0) {
          return extracted;
        }
      }
      
      // If no seats in array but count is set, generate seat numbers 1 to count
      if (count > 0) {
        return Array.from({ length: count }, (_, i) => i + 1);
      }
      
      return [];
    };
    
    // If no date/time specified, return all seats from device configs
    if (!date || !timeSlot || !durationMinutes) {
      return deviceConfigs.map((config: any) => ({
        category: config.category,
        seats: extractSeatNumbers(config)
      }));
    }
    
    // Calculate start and end times for the booking
    const [hours, minutes] = timeSlot.split(':').map(Number);
    const startTime = new Date(date);
    startTime.setHours(hours, minutes, 0, 0);
    const endTime = new Date(startTime.getTime() + durationMinutes * 60000);
    
    // Get existing bookings that overlap with this time slot
    const bookings = await this.getAllBookings();
    const conflictingBookings = bookings.filter((b: any) => {
      if (b.status === 'completed' || b.status === 'cancelled') return false;
      // Ensure we're comparing Date objects
      const bStart = b.startTime instanceof Date ? b.startTime : new Date(b.startTime);
      const bEnd = b.endTime instanceof Date ? b.endTime : new Date(b.endTime);
      // Check for valid dates
      if (isNaN(bStart.getTime()) || isNaN(bEnd.getTime())) return false;
      // Overlap check: booking starts before our end AND booking ends after our start
      return bStart.getTime() < endTime.getTime() && bEnd.getTime() > startTime.getTime();
    });
    
    // Calculate available seats per category
    return deviceConfigs.map((config: any) => {
      const allSeats = extractSeatNumbers(config);
      const occupiedSeats = conflictingBookings
        .filter((b: any) => b.category === config.category)
        .map((b: any) => b.seatNumber);
      const availableSeats = allSeats.filter((s: number) => !occupiedSeats.includes(s));
      return { category: config.category, seats: availableSeats };
    });
  },

  async checkPromotions(category: string, duration: string, personCount: number) {
    // For now return null - promotions not critical for basic booking
    return { discount: null, bonus: null };
  },

  // Report aggregation functions for offline mode
  async getReportStats(period: string, startDate?: string, endDate?: string) {
    const history = await this.getBookingHistory();
    
    // Determine date range based on period
    const now = new Date();
    let filterStartDate: Date;
    let filterEndDate: Date = new Date(now);
    filterEndDate.setHours(23, 59, 59, 999);
    
    if (period === 'daily') {
      filterStartDate = new Date(now);
      filterStartDate.setHours(0, 0, 0, 0);
    } else if (period === 'weekly' && startDate && endDate) {
      filterStartDate = new Date(startDate);
      filterStartDate.setHours(0, 0, 0, 0);
      filterEndDate = new Date(endDate);
      filterEndDate.setHours(23, 59, 59, 999);
    } else if (period === 'monthly' && startDate && endDate) {
      filterStartDate = new Date(startDate);
      filterStartDate.setHours(0, 0, 0, 0);
      filterEndDate = new Date(endDate);
      filterEndDate.setHours(23, 59, 59, 999);
    } else {
      // Default to today
      filterStartDate = new Date(now);
      filterStartDate.setHours(0, 0, 0, 0);
    }
    
    // Filter history by date range
    const filteredHistory = history.filter((record: any) => {
      const recordDate = new Date(record.startTime || record.createdAt);
      return recordDate >= filterStartDate && recordDate <= filterEndDate;
    });
    
    // Calculate stats
    let totalRevenue = 0;
    let totalFoodRevenue = 0;
    let totalSessions = filteredHistory.length;
    let totalMinutes = 0;
    let cashRevenue = 0;
    let upiRevenue = 0;
    
    filteredHistory.forEach((record: any) => {
      const price = parseFloat(record.price) || 0;
      totalRevenue += price;
      
      // Calculate food revenue from foodOrders
      const foodOrders = record.foodOrders || [];
      const foodAmount = foodOrders.reduce((sum: number, order: any) => {
        return sum + (parseFloat(order.price) || 0) * (order.quantity || 1);
      }, 0);
      totalFoodRevenue += foodAmount;
      
      // Calculate session duration
      if (record.startTime && record.endTime) {
        const start = new Date(record.startTime);
        const end = new Date(record.endTime);
        const minutes = Math.max(0, (end.getTime() - start.getTime()) / 60000);
        totalMinutes += minutes;
      }
      
      // Cash and UPI amounts
      if (record.cashAmount) {
        cashRevenue += parseFloat(record.cashAmount) || 0;
      } else if (record.paymentMethod === 'cash') {
        cashRevenue += price + foodAmount;
      }
      
      if (record.upiAmount) {
        upiRevenue += parseFloat(record.upiAmount) || 0;
      } else if (record.paymentMethod === 'upi_online') {
        upiRevenue += price + foodAmount;
      }
    });
    
    const avgSessionMinutes = totalSessions > 0 ? Math.round(totalMinutes / totalSessions) : 0;
    
    return {
      totalRevenue: Math.round(totalRevenue),
      totalFoodRevenue: Math.round(totalFoodRevenue),
      totalSessions,
      avgSessionMinutes,
      cashRevenue: Math.round(cashRevenue),
      upiRevenue: Math.round(upiRevenue),
    };
  },

  async getReportHistory(period: string, startDate?: string, endDate?: string) {
    const history = await this.getBookingHistory();
    
    // Determine date range based on period
    const now = new Date();
    let filterStartDate: Date;
    let filterEndDate: Date = new Date(now);
    filterEndDate.setHours(23, 59, 59, 999);
    
    if (period === 'daily') {
      filterStartDate = new Date(now);
      filterStartDate.setHours(0, 0, 0, 0);
    } else if ((period === 'weekly' || period === 'monthly') && startDate && endDate) {
      filterStartDate = new Date(startDate);
      filterStartDate.setHours(0, 0, 0, 0);
      filterEndDate = new Date(endDate);
      filterEndDate.setHours(23, 59, 59, 999);
    } else {
      filterStartDate = new Date(now);
      filterStartDate.setHours(0, 0, 0, 0);
    }
    
    // Filter and transform history
    const filteredHistory = history.filter((record: any) => {
      const recordDate = new Date(record.startTime || record.createdAt);
      return recordDate >= filterStartDate && recordDate <= filterEndDate;
    });
    
    return filteredHistory.map((record: any) => {
      const foodOrders = record.foodOrders || [];
      const foodAmount = foodOrders.reduce((sum: number, order: any) => {
        return sum + (parseFloat(order.price) || 0) * (order.quantity || 1);
      }, 0);
      
      // Calculate duration string
      let duration = '';
      if (record.startTime && record.endTime) {
        const start = new Date(record.startTime);
        const end = new Date(record.endTime);
        const minutes = Math.round((end.getTime() - start.getTime()) / 60000);
        if (minutes < 60) {
          duration = `${minutes} mins`;
        } else {
          const hours = Math.floor(minutes / 60);
          const remainingMins = minutes % 60;
          duration = remainingMins > 0 ? `${hours}h ${remainingMins}m` : `${hours}h`;
        }
      }
      
      const price = parseFloat(record.price) || 0;
      
      return {
        id: record.id,
        date: record.startTime || record.createdAt,
        seatName: record.seatName || `${record.category}-${record.seatNumber}`,
        customerName: record.customerName || 'Unknown',
        duration,
        price: price.toString(),
        foodAmount,
        totalAmount: price + foodAmount,
        paymentMethod: record.paymentMethod,
        paymentStatus: record.paymentStatus || 'paid',
        cashAmount: record.cashAmount?.toString() || null,
        upiAmount: record.upiAmount?.toString() || null,
        discount: record.discount?.toString() || null,
        bonus: record.bonus?.toString() || null,
        discountApplied: record.discountApplied,
        bonusHoursApplied: record.bonusHoursApplied,
      };
    });
  },
};
